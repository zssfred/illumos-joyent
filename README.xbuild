 _ _ _                                                                
(_) | |_   _ _ __ ___   ___  ___    ___  _ __     __ _ _ __ _ __ ___  
| | | | | | | '_ ` _ \ / _ \/ __|  / _ \| '_ \   / _` | '__| '_ ` _ \ 
| | | | |_| | | | | | | (_) \__ \ | (_) | | | | | (_| | |  | | | | | |
|_|_|_|\__,_|_| |_| |_|\___/|___/  \___/|_| |_|  \__,_|_|  |_| |_| |_|


Welcome brave fool. Don't Panic! The writer of this README is an even bigger
fool than you could be (even if old Ben wonders if those who follow fools are
more foolish).

So here's where you get started building illumos on ARM.

Step 1) You need to get a build environment set up. There's the easy way and the
fun way.

Easy way:

cd $HOME
curl -O https://fingolfin.org/illumos/arm/armtc.tar.gz
pfexec tar xvzf armtc.tar.gz -C /
find /opt/armtc

Fun way:

Using a normal i386 on i386 build:
cd usr/src
dmake setup
cd cmd/sgs
dmake install

mkdir -p /opt/armtc/lib/amd64 /opt/armtc/usr/bin/amd64
cd /opt/armtc/lib/
ln -s amd64 64
cd ../usr/bin
ln -s amd64 64

Then from your proto area, install the following:
 o /usr/bin/ld
 o /usr/bin/amd64/ld
 o /lib/libld.so.4
 o /lib/amd64/libld.so.4
 o /lib/liblddbg.so.4
 o /lib/amd64/liblddb.so.4
 o /lib/libelf.so.1
 o /lib/amd64/libelf.so.1

Now that's all set go grab illumos-arm-extra (git clone
gitosis@zelgadis.fingolfin.org:illumos-arm-extra.git) and build that. You'll
need something like:

gmake ARCH=arm STRAP=strap LD_ALTEXEC=/opt/armtc/usr/bin/ld install

Once that's done, you'll need to fix up the rpath there. so from the root of
that workspace run:

./tools/setrpath proto-arm/usr/ /opt/armtc/usr/lib:/opt/gcc/4.4.4/lib:/lib:/usr/lib

Finally, you can copy all of that into your arm compiler toolchain directory
(use pfexec / sudo as appropriate):

cp -r proto-arm/usr /opt/armtc/

Step 2) Set up illumos.sh

In a fresh workspace, you're going to want to set up your illumos.sh with the
following:

# Enable GCC 4 default
export __GNUC="";
export CW_NO_SHADOW=1
export MACH=arm;
export NATIVE_MACH=i386;
export BUILD64="#"
 
# Re-set all this MACH-based crud
REF_PROTO_LIST=$PARENT_WS/usr/src/proto_list_${MACH}; export REF_PROTO_LIST
ROOT="$CODEMGR_WS/proto/root_${MACH}"; export ROOT
PARENT_ROOT=$PARENT_WS/proto/root_$MACH; export PARENT_ROOT
PKGARCHIVE="${CODEMGR_WS}/packages/${MACH}/nightly"; export PKGARCHIVE
unset GCC_ROOT GNU_ROOT CW_GCC_DIR
export i386_GCC_ROOT=/opt/gcc/4.4.4
export arm_GCC_ROOT=/opt/armtc/usr
export i386_GNU_ROOT=/usr/sfw
export arm_GNU_ROOT=/opt/armtc/usr/gnu

#
# XXX our gcc isn't called ./usr/bin/gcc fix it up via CW env vars for now.
#
export CW_arm_GCC=/opt/armtc/usr/bin/arm-pc-solaris2.11-gcc-4.6.3

#
# XXX We need to set CPP to our specific cpp, not the generic /usr/ccs/lib/cpp
# as that's rather, well, x86.
#
export CPP=/opt/armtc/usr/lib/cpp
export AW_CPP=/opt/armtc/usr/lib/cpp
export LD_ALTEXEC=/opt/armtc/usr/bin/ld

Step 3) Start your build engines

Once you've done that, you're doing to need to need to use the *new* bldenv to
get started building. For the first time you can go ahead and do something like: 

cd usr/src
ksh93 ./tools/scripts/bldenv.sh ../../illumos.sh

This is really just a bit of a bootstrapping weirdness. Once that's done you can
go ahead and continue on.

As a part of this you should see an important two lines:

Cross-building enabled
Targeting arm on i386

If you don't, stop. illumos.sh is not configured correctly.


Once you have that you can get going. Start off with a resounding:

dmake setup

Following this, you can build the kernel as far as we have it for ARM

cd uts; dmake install

You now have a lovely unix and boot_archive pair in bcm2835/unix (Raspberry
Pi) and qvpb/unix (qemu versatilepb).

Step 4) Boot

Now that you have the gate built, you can try to boot the kernel.  This is
where things diverge between qemu and the Raspberry Pi.

Booting qemu is very easy:

qemu-system-arm \
	-kernel $PROTO/platform/qvpb/kernel/loader \
	-initrd $PROTO/platform/qvpb/kernel/initrd \
	-machine versatilepb \
	-cpu arm1176 \
	-m 512 \
	-no-reboot \
	-nographic \
	-append 'kernel /platform/qvpb/kernel/unix -Bconsole=uart'

The loader and kernel messages should appear in the same terminal.

Booting on real hardware is a bit more involved.

  a) Create a FAT16 or FAT32 partition on the SD card.  You'll want it to be
     at least 40 MB.

  b) Create a config.txt on the partition:

	gpu_mem=64
	kernel=loader
	initramfs initrd 0x00800000

  c) Create a cmdline.txt on the partition:

	kernel /platform/bcm2835/kernel/unix -Bconsole=uart

  d) Place Raspberry Pi firmware onto the partition.  You can download
     latest firmware from
     https://github.com/raspberrypi/firmware/tree/master/boot. The firmware
     from January 24th, 2015 is known to work.

	0e52c8cdbfd21631746d6fcdc8f2750af39f4287  bootcode.bin
	aba25d795eaddafd5c8ece3de18873b9928eb6f7  fixup_cd.dat
	38e55d60f896738eec30d0ca4f62b68e48e99184  fixup.dat
	4867e6eab84bb4138e812993112b6a05b7930b89  fixup_x.dat
	fa993851acba366d9e37d59a1d9e9de84b19173f  start_cd.elf
	356060e0f44742d8835294a211b812efcac29f66  start.elf
	b7f01f90d995a36c9d765fd1f4d95a5fcdfd7e41  start_x.elf

  e) Copy $PROTO/platform/bcm2835/kernel/{loader,initrd} onto the partition.
